computational context
- a functor ที่เตรียม context กับ computation ที่เกิดขึ้น

Xap :: X (a -> b) -> X a -> X b
X = type constructor

Applicative
- เป็น functor ที่ทำให้เป็น computational context เมื่อใช้ op pure
การคำนวณที่เป็น sequence computational context combine result by ap 
- Applicative is mathematicals structure

law 1: identity law
pure id <*> v = v

*for Maybe
pure id <*> Nothing
= Just id <*> Nothing
= Nothing

pure id <*> Just x
= Just id <*> Just x
= Just (id x)
= Just x

law 2: composition
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
u :: X (b -> c), v :: X (a -> b), w :: X a

*for Maybe
pure (.) <*> Nothing <*> v <*> w 
= Nothing = Nothing <*> (v <*> w)
pure (.) <*> u <*> Nothing <*> w 
= Nothing = u <*> (Nothing <*> w)
pure (.) <*> u <*> v <*> Nothing 
= Nothing = u <*> (v <*> Nothing)

pure (.) <*> Just x <*> Just y <*> Just z 
= Just (x . y) <*> Just z = Just ((x.y) z)
= Just (x $ (y z)) = Just x <*> Just (y z)
= Just x <*> (Just y <*> Just z)

law 3: homomorphism
pure f <*> pure x = pure (f x)
f :: a -> b
x :: a

*for Maybe
pure f <*> pure x = pure f <*> Just x 
= Just (f x) = pure (f x)

law 4: interchange
u <*> pure y = pure ($ y) <*> u
u :: X (a -> b)
y :: a
($ y) :: (a -> b) -> b

*for Maybe
Nothing <*> pure y
= Nothing
= pure ($ y) <*> u

Just f <*> pure y
= Just f <*> Just y = Just (f y)
= Just (f $ y) = Just (($ y) f)
= Just ($ y) <*> Just f
= pure ($ y) <*> Just f

Applicative functor as delayed computation
= ต้องหาสักตัวเพื่อมาปลดล็อก computation
